// ----------------------------------------------------
// https://dbdiagram.io/
// ----------------------------------------------------

// ----------------------------------------------------
// Use PostgreSQL
// ----------------------------------------------------
Project meeting_room_booking {
  database_type: 'PostgreSQL'
  Note: 'Database schema for a meeting room booking system.'
}


// ----------------------------------------------------
// Enums
// ----------------------------------------------------
Enum enum_gender {
  male
  female
  unknown
}

Enum enum_employee_status {
  active
  resigned
  probation
  retired
}

Enum enum_room_status {
  available
  maintenance
  disabled
  reserved // For rooms permanently reserved for special use (e.g., CEO's office)
}

Enum enum_rsvp_status {
  accepted
  declined
  tentative
  pending
}


// ----------------------------------------------------
// Tables
// ----------------------------------------------------
Table departments {
  id int [pk, increment]
  name varchar(50) [unique, not null]
  parent_department_id int [ref: > departments.id] // Self-referencing foreign key. NULL means it's a top-level department.
}

Table positions {
  id int [pk, increment]
  name varchar(50) [unique, not null]
}

Table employees {
  id int [pk, increment]
  name varchar(50) [not null]
  gender enum_gender
  department_id int [ref: > departments.id]
  position_id int [ref: > positions.id]
  phone varchar(20) [unique]
  email varchar(50) [unique, not null]
  hire_date date [not null]
  leave_date date
  status enum_employee_status [not null, default: 'probation']
}

Table office_area_countries{
    id int [pk, increment]
    name VARCHAR(50) [not null]
}

Table office_area_provinces{
    id int [pk, increment]
    name VARCHAR(50) [not null]
    country_id int [ref: > office_area_countries.id]
}

Table office_area_cities{
    id int [pk, increment]
    name VARCHAR(50) [not null]
    province_id int [ref: > office_area_provinces.id]
}

Table office_area{
    id int [pk, increment]
    name VARCHAR(50) [not null]
    city int [ref: >  office_area_cities.id]
    geom GEOGRAPHY(Point, 4326) [not null]
}

Table rooms {
  id int [pk, increment]
  room_number varchar(10) [unique, not null]
  name varchar(50) [not null]
  office_area_id int [not null, ref: > office_area.id]
  floor smallint [not null]
  capacity smallint [not null]
  status enum_room_status [not null, default: 'available']
  has_projector boolean [not null, default: false]
  has_whiteboard boolean [not null, default: false]
  has_video_conference boolean [not null, default: false]
  description text
}

Table meetings {
  id int [pk, increment]
  booking_number char(9) [unique, not null]
  title varchar(50) [not null]
  room_id int [not null, ref: > rooms.id]
  organizer_id int [ref: > employees.id]
  start_time timestamptz [not null]
  end_time timestamptz [not null]
  is_canceled boolean [not null, default: false]
  description text

  Note: 'A CHECK constraint (end_time > start_time) should be added manually in SQL.'
}

// Junction Table for Many-to-Many relationship between meetings and employees
Table meeting_participants {
  meeting_id int [not null, ref: > meetings.id]
  employee_id int [not null, ref: > employees.id]
  rsvp_status enum_rsvp_status [not null, default: 'pending']

  // Composite Primary Key
  indexes {
    (meeting_id, employee_id) [pk]
  }
}


// ----------------------------------------------------
// Indexes
// ----------------------------------------------------
// Note: Indexes below are for performance and are added in addition to the PK/FK indexes.
// dbdiagram.io doesn't visualize all index types, but it's good practice to document them.
// CREATE INDEX idx_meetings_time ON meetings (room_id, start_time, end_time);
// CREATE INDEX idx_meeting_participants_employee ON meeting_participants (employee_id);
// CREATE INDEX idx_meetings_organizer ON meetings (organizer_id);